## 연산자

> 연산자: 연산을 수행하는 기호

## 연산자와 피연산자

연산자는 연산을 수행하는 기호이고 피연산자는 연산자의 작업 대상이다. 예를 들어 x+7의 경우 +는 연산자이고 x, 7은 피연산자이다. 연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.

## 식과 대입 연산자

연산자와 피연산자의 조합을 식이라고 한다. 이것은 변수에 넣지 않으면 사라진다.

## 연산자의 종류

연산자는 종류가 많지만, 기능이 비슷한 것들을 묶어 놓고 보면 몇 개 되지 않는다.

- 산술 연산자: `+`, `*`, `-`, `/`, `%` (비트연산자) `>>`, `<<`
- 비교 연산자: `>`, `<`, `>=`, `<=`, `==`, `!=`
- 논리 연산자: `&&`, `||`, `!`, `&`, `|`, `^`, `~`
- 대입 연산자: `=`
- 기타: `(type)`, `?:`, `instanceof`

기타 연산자 `(type)`은 형변환, `?:`은 삼항식, `instanceof`는 객체의 타입을 확인하는 연산자이다.

### 연산자의 개수에 따른 분류

연산자는 단항 연산자, 이항 연산자, 삼항 연산자가 존재한다. 단항은 하나의 피연산자를 가지는 연산자이고 이항은 두개, 삼항은 세개다. 보통 단항 연산자가 가장 우선순위가 높아서, 이거만 기억하면 된다.

### 연산자 우선순위

보통 수학에서 사용하는 것과 비슷하다.

1. 산술 > 비교 > 논리 > 대입. 대입 연산자가 가장 마지막에 사용된다.
2. 단항 > 이항 > 삼항.
3. 단항 연산자와 대입 연산자를 제외하곤 계산의 순서는 항상 왼쪽에서 오른쪽이다.

이 부분을 공부했다고 그대로 두지 말고 항상 `()` 표시를 이용해 가독성을 좋게 해야한다.

## 산술 변환

`(type)` 연산자이다. 피연산자의 타입이 다르다면, 형변환 연산자로 타입을 일치시켜주어야 한다.

```java
String name = (String) session.getAttribute("NAME");
```

실제 세션에서 값을 받아와 저장하는 구문이다. session은 객체의 조상격인 Object 타입을 기본적으로 가지고 있기 때문에, 이렇게 형변환을 시켜주어야 한다.

**부록**: `(String)`, `toString()`, `String.valueOf(변수)` 세 가지 모두 String으로 형변환을 시켜주는 자바 구문이다. `(String)`과 같이 type 연산자를 사용하면 자바에게 이 변수는 String이다! 하고 알려주는 구문이고, `toString()`은 String으로 형변환을 시켜주는 구문이다. 코딩상으로는 컴파일러에 형식을 알려주기만 하는 `(String)`가 가장 깔끔하고 `toString()`같은 함수는 경우는 null일 경우 오류가 발생한다. `String.valueOf()`는 `toString()`을 조금 더 잘 사용하도록 변경한 구문이라고 생각한다.

## 단항 연산자

`++`, `--`만 주로 사용한다.

`++`는 1이 증가 `--`는 1이 감소한다. 이 때 전위형과 후위형으로 나뉘어서 사용되는데 이에 따라 결과가 달라질 수 있다.

```java
int i = 5;
int j = 0;

j = i++;
System.out.println("j=i++ 실행 후 i=" + i + ", j=" + j);

i = 5;
j = 0;

j = ++i;
System.out.println("j=++i 실행 후 i=" + i + ", j=" + j);
```

![증감 연산자 실행 결과](https://velog.velcdn.com/images/honggilgim/post/d53f6477-8793-4935-8cc9-d48bafb21809/image.png)

헷갈려서 책의 예제를 쳐서 실습했다. `i++`를 쓰면 대입 후 계산하고, `++i`를 쓰면 계산 후 대입한다.

이 증감연산자를 잘 사용하면 깔끔한 코드를 짤 수 있지만, 반대로 코드의 가독성이 떨어지기도 한다.

## 산술 연산자

`+`, `-`, `*`, `/`이다. 사칙연산을 사용할 때 자주 사용하는 연산자이다.

이 연산자들은 자주 사용하지만, 조심해야 한다. 특히 `int / int`의 경우 나머지값은 버려지고 int로 형변환된다. 8 / 3은 프로그래밍 언어에서 소수점을 받는 float이나 double이 아닌 경우 2가 된다.

특히 작은 연산자에서 계산을 할 경우 형변환으로 인한 데이터 손실이 발생할 수 있다.

### 값의 손실 예제

![값의 손실 예제](https://velog.velcdn.com/images/honggilgim/post/d422e5d7-9de4-42e1-8273-b4352e36a0c7/image.png)

실습해봤는데, 자바 버전이 올라감에 따라 에러가 난다. (실습환경 java17)

그래도 알고리즘 문제를 풀다 보면, 그리고 현업에서 은근히 자주 발생하는 상황이라 신경써주는 일이 필요하다.

### 문자열 비교

사칙연산의 연산자는 숫자뿐이 아닌 문자도 가능하다. 이는 문자열이 유니코드로 저장되기 때문인데 예시로

![문자 연산 예제](https://velog.velcdn.com/images/honggilgim/post/68f68bae-f879-49f3-927b-a236ab48b950/image.png)

이런 구문이 가능하다. 실제로 숫자로 된 char형 변수를 '0'을 빼서 사용하는 일은 알고리즘 문제를 풀 때 생각보다 많이 사용된다. 알파벳 같은 경우도 순서대로 저장되어 있기 때문에

![알파벳 연산 예제](https://velog.velcdn.com/images/honggilgim/post/80905d5a-84d8-4355-b00a-a5c266bae731/image.png)

이런 식으로 알파벳의 숫자를 구할 수 있다. 하지만,

![String 연산 불가](https://velog.velcdn.com/images/honggilgim/post/ca67f138-a4f6-4bc8-8a6d-aec853eb8fa3/image.png)

String 형식은 안된다.

이게 가능한 이유는 리터럴 간의 연산이기 때문이다. 상수 또는 리터럴 간의 연산은 실행 과정동안 변하는 값이 아니기에 컴파일 시 컴파일러가 계산하여 코드를 보다 효율적으로 만든다.

![변수 연산 예제](https://velog.velcdn.com/images/honggilgim/post/14d9dca3-7deb-4a21-81f2-a6792bb509b4/image.png)

이렇게 변수에 담아 계산해도 올바르게 동작한다. 알고리즘에서 많이 쓰이는 구문이다.

![대소문자 변환 예제](https://velog.velcdn.com/images/honggilgim/post/d6970c2e-9994-4efd-8db2-9dd09b25350d/image.png)

이런 구문도 많이 사용되는데, 소문자 a가 대문자 A보다 유니코드로 32 많은 값을 가지고 있어 이렇게 형변환할 경우 대문자 A가 된다.

## 비교 연산자

비교 연산자는 두 피연산자를 비교하는 데 사용된다. 결과는 오직 true, false 뿐이다. 이 연산자 역시 이항 연산자이기에 타입이 다를 경우는 자료형의 큰 쪽으로 자동 형변환하여 비교한다. 이 점에 주의해야 한다.

`<`, `>`, `<=`, `>=` 이렇게 존재하며, 참조형 변수와 boolean을 제외한 모든 타입에 사용이 가능하다.

주의할 점으로 자바는 `<=`, `>=`의 순서를 바꿀 경우 오류난다.

### ==, !=

비교 연산자이다.

`==`은 값이 같을 경우 true, 틀릴 경우 false

`!=`은 값이 다를 경우 true, 틀릴 경우 false를 반환한다.

주의할 점은 참조형 변수는 주소를 비교하기 때문에 값이 같아도 false를 출력할 수 있다. 그래서 String 같은 참조형 변수를 사용할 경우 `.equals()` 함수를 사용한다.

또한,

```java
float a = 0.1f;
double b = 0.1;

if(a == b)
    System.out.println("true");
else
    System.out.println("false");
```

![float과 double 비교](https://velog.velcdn.com/images/honggilgim/post/d32e8fa2-db75-4d13-a7cd-c982e0cc0a38/image.png)

서로 다른 자료형인 float와 double을 비교 시, false값이 출력된다.

그 이유는 float을 형변환하는 과정에서 오차가 발생하기 때문이다.

이러한 자료형의 비교는

```java
if(a == (float)b)
```

이렇게 진행해주어야 한다.

## 논리 연산자

논리 연산자는 `&&`, `||`, `!`가 존재한다.

- `||`: OR (두 가지 조건 중 하나만 참이면 참) - A또는B
- `&&`: AND (두 가지 조건 모두 참이면 참) - A이고B
- `!`: NOT (참일 경우 거짓) - A가 참이면 거짓, 거짓이면 참

이렇게 해당하는 연산자이다.

### 효율적인 연산

논리 연산자는 연산의 순서에 따라 한 조건이 true일 경우 좌측 피연산자만 검사하고 우측 피연산자 값은 계산하지 않는다.

`||`의 경우 좌측 피연산자가 true일 경우 전체가 true이고, `&&` 연산은 좌측 피연산자가 false일 경우 전체가 false이다.

Null 값과 같은 구문을 체크할 경우 자주 사용되는 연산법인데,

```java
if(param != null && param.equals("s"))
```

이런 식으로 NPE 방지를 하고 그 이후 구문을 적어줌으로써 보다 효율적으로 비교문을 사용할 수 있다. 위 구문에서 param이 null일 경우 NPE가 발생하는데 이런 함수를 사용할 때 이를 효율적으로 방지할 수 있다.

사실 위 구문은 `"S".equals(param)`으로 변경하면 방지가 가능하긴 하다.

## 그 외 연산자

### 삼항 연산자

`(조건) ? (참) : (거짓)`

으로 사용되며 이는 코드를 깔끔하게 해준다.

```java
if(a == (float)b)
    System.out.println("true");
else
    System.out.println("false");

System.out.println(a == b ? "true" : "false");
```

위 if 조건문과 아래 구문이 똑같이 작동한다.

### 대입 연산자

대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는 일에 사용한다. 주의해야 할 점은, 대입 연산자만이 왼쪽에서 오른쪽이 아닌 오른쪽에서 왼쪽으로 구문이 실행된다는 것이다.

