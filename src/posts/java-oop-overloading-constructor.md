## 오버로딩

### 오버로딩이란?

한 클래스 내에서 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩 또는 오버로딩이라고 한다. 하나의 메서드 이름에 보통 하나의 기능을 구현하지만, 하나의 메서드에서 여러 기능을 구현할 수 있다.

### 조건

메서드 오버로딩은 같은 이름의 메서드를 여러 개 정의한다고 해서 되는 것이 아니다. 보통,

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

라는 2가지 조건이 붙는다. 비록 메서드의 이름이 같더라도 매개변수가 다르다면 구별이 가능하기에, 이런 구현이 가능하다. 만약 이렇게 구현하지 않는다면 컴파일 시 에러가 발생한다. 또한, 반환 타입은 메서드 오버로딩에 아무런 영향을 주지 않는다.

### 오버로딩의 예시

오버로딩의 대표적인 예시는, `System.out.println`이다. 이 메서드는 지정하는 값의 타입에 따라 다른 메서드를 호출하며, 어떤 종류의 매개변수를 출력해도 전부 출력할 수 있도록 총 10개의 메서드를 오버로딩 해 구현되어 있다.

오버로딩은, 같은 인수를 받고 같은 리턴값을 준다면 오류가 발생한다. 똑같은 메서드이기에 컴파일러에서 구분하지 못한다. 그리고 같은 인수를 받고 다른 형식의 리턴값을 반환한다면 역시 오류가 발생한다. 반환값으로는 구분이 불가능하다. 하지만, 메서드의 다른 형식의 숫자가 다르다면 오류가 발생하지 않는다.

```java
int add(int x, int y);
long add(int x, int y);
// 불가능

long add(int a, long b);
long add(long a, int b);
// 가능
```

물론 가능은 하지만, 좋지 못한 구현 방식이다. 만약 정의된 매개변수가 다르더라도 같은 일을 할 경우 이름을 같게 하고 매개변수를 다르게 하여 오버로딩을 구현하곤 한다.

### 오버로딩의 장점

근본적으로 같은 기능을 하는 메서드들은 다른 타입의 변수를 받더라도 메서드를 선언 또는 사용할 때 헷갈릴 수 있다. 이 부분을 완화시켜주기 위해 오버로딩을 사용한다. `System.out.println()`과 같은 평범한 자바 함수를 사용할 때, String, int, long, bool, Object 등 다양한 타입에 맞게 이름이 다르다면, 사용 및 관리에 매우 어려울 것이다. 이 때문에 오버로딩이 사용된다.

보통 그래서, 메서드의 이름을 같게 하여 구현할 경우 같은 기능을 수행하도록 코드를 작성하는 경우가 많다. 메서드의 이름을 같게 함으로써 같은 기능을 수행한다는 점을 알려주고, 이를 쉽게 예측할 수 있게 해주며 메서드의 이름을 짓는 자원 역시 절약할 수 있다.

### 가변인자와 오버로딩

JDK 1.5부터 추가된 기능이다. 기존에는 메서드의 매개변수 개수가 고정적이었으나, 동적으로 지정이 가능하다. 이를 가변인자라고 한다. 가변인자는,

```java
public PrintStream printf(String format, Object... args) {}
```

의 형식으로 선언된다. 그리고 가장 마지막에 가변인자를 써 주어야 오류가 발생하지 않는다.

```java
String add(String s1, String s2) {...}
String add(String s1, String s2, String s3) {...}
String add(String s1, String s2, String s3, String s4) {...}
...
```

의 형식으로 오버로딩을 이어가야 하는 함수를,

```java
String add(String... str) {...}
```

로 대체 가능하다. 가변인자는 내부적으로 배열을 사용해서 메서드 변수를 손쉽게 통제할 수 있게 해 준다. 하지만 배열이므로, 다소 비효율적이다.

## 생성자

생성자는 인스턴스가 생성될 때 호출되는 **인스턴스 초기화 메서드**이다. 인스턴스 초기화 작업에 주로 사용되며, 인스턴스 생성 시 실행되어야 할 작업을 위해서도 사용된다.

생성자 역시 메서드처럼 클래스 내에 선언이 가능하며, 구조도 메서드와 유사하지만 리턴값이 없다. 생성자는,

1. 생성자의 이름은 클래스의 이름과 같아야 한다.
2. 생성자는 리턴 값이 없다.

라는 조건이 있다.

또한 생성자 역시 오버로딩이 가능하다. 하나의 클래스에 여러 개의 생성자를 오버로딩해 필요에 따라 사용이 가능하다.

```java
class Example {
    Example() {...}
    Example(int a, int b) {...}
}
```

이런 식으로 오버로딩 해서 사용이 가능하다. 생성자를 사용할 때 많이 사용하는 new 연산자는 인스턴스를 생성하는 기능을 한다.

이 **new 연산자가 인스턴스를 생성하는 일을 하지 생성자는 인스턴스를 직접 생성하지 않는다.**

생성자는 인스턴스 생성이 아닌, 초기화에 사용되는 조금 특별한 메서드이다.

생성자의 실행 과정은

1. new 연산자에 의해 메모리에 인스턴스가 생성된다.
2. 생성자에 의해 메서드가 호출되어 실행된다.
3. 연산자 new의 결과로, 인스턴스의 주소가 참조형 변수에 저장된다.

라는 구조를 가진다.

### 기본 생성자

생성자를 모르고 그냥 프로그래밍을 해도 아무런 이상 없이 작동한다. 하지만 모든 클래스에는 기본적으로 생성자가 하나씩은 꼭 포함되어 있어야 한다. 컴파일러는, 모든 클래스에 기본 생성자를 제공한다. 만약 클래스에 생성자가 하나도 정의되어 있지 않다면,

`클래스이름() {}` 라는 생성자를 컴파일러가 클래스에 추가한다. 보통 생성자는 컴파일러가 제공하는 기본 생성자를 많이 사용한다. 하지만 매개변수가 있는 생성자를 선언한다면, 컴파일러는 기본 생성자를 추가해주지 않는다. 컴파일러는 오직 생성자가 하나도 생성되어 있지 않은 클래스 파일에 기본 생성자를 자동으로 추가해준다.

### 생성자에서 다른 생성자 호출하기 - this(), this

생성자 간에도 조건이 맞다면 호출이 가능하다.

1. 생성자의 이름으로 클래스의 이름 대신 this를 사용한다.
2. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

이 this는, 참조변수로 인스턴스 자신을 가리킨다. 참조변수를 통해 인스턴스 멤버에 접근이 가능한 것처럼 this는 인스턴스 변수에 접근할 수 있도록 해준다. 하지만, this는 인스턴스 멤버에만 사용이 가능하며 클래스 멤버(static 메서드)에는 사용이 불가능하다. static 메서드는 인스턴스 생성 없이 호출이 가능하므로 static 메서드가 호출된 시점에 인스턴스가 없을 수도 있기 때문이다.

생성자를 포함하는 모든 인스턴스 메서드에는 자신이 관련된 인스턴스를 가리키는 this가 지역변수로 숨겨진 채 존재한다.

- **this**: 인스턴스 자신을 가리키는 참조변수로, 인스턴스의 주소로 저장되어 있다. 모든 인스턴스 메서드에 숨겨진 채로 존재한다.
- **this(), this(매개변수)**: 생성자로, 같은 클래스의 다른 생성자를 호출할 때 사용한다.

이 this는, getter나 setter와 같은 함수에서 쉽게 찾아볼 수 있다.

```java
public int getFoo() {
    return this.foo;
}

public void setFoo(int foo) {
    this.foo = foo;
}
```

Lombok에서 제공해주는 getter와 setter의 기본 형태이다. getter는 `this.foo`를 리턴해 이 객체의 foo를 리턴하고, setter는 `this.foo`에 foo 값을 저장한다.

## 변수의 초기화

이전 변수에 대해 학습할 때, 기본형 변수는 기본 값을 가진다고 학습했다. int는 0과 같이 기본값을 가지지만, 이는 멤버 변수에 대한 속성이다. 멤버변수는 초기화를 하지 않아도 기본적으로 기본값을 가지지만, 지역변수는 사용하기 전에 반드시 초기화해야 한다.

```java
class Test {
    int x;
    int y = x; // 인스턴스 변수는 초기화 하지 않아도, 기본값이 지정된다.
    
    void add() {
        int x;
        int y = x; // 지역변수는 에러가 발생한다.
    }
}
```

멤버변수인 클래스변수와 인스턴스변수 및 배열의 초기화는 선택적이지만, 지역변수는 항상 초기화해주어야 한다. 물론 코드의 가독성을 생각하면 그냥 초기화해주는 게 낫다.

멤버변수의 초기화는 지역변수와 달리 여러 가지 방식이 있다.

1. 명시적 초기화
2. 생성자
3. 초기화 블럭
   - 인스턴스 초기화 블럭
   - 클래스 초기화 블럭

### 1. 명시적 초기화

명시적 초기화는 변수의 선언과 동시에 초기화하는 방식이다. 가장 기본적이고, 가장 간단하며, 가장 가독성이 좋다. 또한 가장 많이 사용된다.

```java
class Test {
    int x = 4; // 기본형 변수 초기화
    Example exa = new Example(); // 참조형 변수의 초기화
}
```

### 2. 초기화 블럭

초기화 블럭에는 클래스 초기화 블럭, 인스턴스 초기화 블럭이라는 두 가지 종류가 있다. 클래스 초기화 블럭은 클래스의 초기화에 인스턴스 초기화 블럭은 인스턴스의 초기화에 사용된다. 둘 모두 복잡한 초기화에 사용된다는 점은 같다. 인스턴스 초기화 블럭은 간단하게 클래스 내부에 `{}`를 붙이고 그 안에 코드를 작성하기만 하면 된다. 클래스 초기화 블럭은 역시 간단하게 `{}`앞에 static을 붙이기만 하면 된다.

```java
class Test {
    {...} // 인스턴스 초기화 블럭
    static {...} // 클래스 초기화 블럭
}
```

클래스 초기화 블럭은 메모리가 처음 로딩될 때 한번 수행되며, 인스턴스 초기화 블럭은 생성자를 호출해 인스턴스가 처음 생성될 때 실행된다. 이 때, 인스턴스 초기화 블럭은 생성자보다 먼저 수행된다.

```java
class Math {
    static {
        System.out.println("static 초기화");
    }
    {
        System.out.println("인스턴스 초기화");
    }
    Math() {
        System.out.println("생성자");
    }
}

public class Main {
    public static void main(String[] args) {
        Math test = new Math();
        Math test2 = new Math();
    }
}
```

간단하게 테스트 코드를 작성했다.

![초기화 블럭 실행 결과](https://velog.velcdn.com/images/honggilgim/post/f4883919-47e7-48f0-b4e4-d8b7d5e39602/image.png)

확인해보면, 처음에 static 초기화가 일어나고 그 후 인스턴스 초기화가 생성자가 호출되기 전에 일어난다. 이 기능을 잘 사용하면 코드의 중복을 제거해 코드의 신뢰성을 높여 주고, 오류의 발생 가능성을 줄여 준다. 또한 재사용성도 높여 준다. 이것이 바로 객체지향이 추구하는 목표이다.

## 정리

멤버변수는,

- **클래스변수의 초기화 시점**: 클래스가 처음 로딩될 때 단 한번 초기화 된다.
- **인스턴스 변수의 초기화 시점**: 인스턴스가 생성될 때마다 각 인스턴스별로 초기화된다.
- **클래스변수의 초기화 순서**: 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
- **인스턴스 변수의 초기화 순서**: 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

```java
class Test {
    static int number = 1;
    int testnumber;
    {
        number++;
        testnumber = number;
    }
}

public class Main {
    public static void main(String[] args) {
        Test t1 = new Test();
        Test t2 = new Test();
        Test t3 = new Test();

        System.out.println("1번째 : " + t1.testnumber);
        System.out.println("2번째 : " + t2.testnumber);
        System.out.println("3번째 : " + t3.testnumber);

        System.out.println("static 변수 (클래스 변수) : " + Test.number);
    }
}
```

간단한 테스트 코드이다. 실제로 실행해보면,

![초기화 순서 테스트 결과](https://velog.velcdn.com/images/honggilgim/post/c78f84dd-4e8a-435a-b397-5529cfa4dd01/image.png)

static 변수가 어떻게 실행되고 초기화가 어떤 식으로 실행되는지 확인할 수 있다. 이 점을 잘 사용한다면 더욱 효율적인 자바 코드를 작성할 수 있을 것이다.

