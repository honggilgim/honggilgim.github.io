## 다형성 (polymorphism)

### 다형성이란?

다형성은 상속과 함께 객체지향의 중요한 특징 중 하나로, 상속과 크게 연관되어 있는 개념이다.

객체지향에서 다형성은 여러 가지 형태를 가질 수 있는 능력을 의미하며 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그래밍적으로 구현하는 일에 성공했다.

**조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 하는 것** 이것이 다형성이다.

```java
class Parents {
    int a;
    int b;
    
    void one() {...}
    void two() {...}
    void three() {...}
}

class Child extends Parents {
    int c;
    void four() {...}
}
```

의 자손과 부모 클래스가 있을 경우,

```java
Parents p = new Child();
Child c = new Child();
```

와 같이 두 가지 형식으로 인스턴스를 생성할 수 있다. 이 두 가지 인스턴스 모두 child 타입이더라도, 참조변수 p로는 child의 모든 멤버를 사용할 수 없다.

Parents 타입의 참조변수는 오직 child의 인스턴스 중에서 parents의 멤버들 즉 상속받은 멤버들만 사용이 가능하다. 따라서, 생성된 parents 타입의 인스턴스로는 child의 멤버 int c, void four() 메소드를 사용하지 못한다. 즉 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.

하지만, 자손 클래스에서 조상 타입의 인스턴스를 참조하는 일은 불가능하다. 참조변수로 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 작아야 한다.

**조상타입의 참조변수로도 자손클래스의 인스턴스를 참조할 수 있고, 그 차이로 자손타입에서 만든 메서드나 변수는 사용이 불가능하고 오직 조상타입에서 상속받은 변수만 사용이 가능하다.**

## 참조변수의 형변환

참조변수 역시 형변환이 가능하다. 단, 서로 상속관계에 있는 클래스에서만 가능하고 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수로의 형변환 만이 가능하다.

기본형 변수의 형변환에서 작은 자료형에서 큰 자료형으로는 생략이 가능하듯 참조형 변수의 형변환에서는 자손타입의 참조변수를 조상타입으로 형변환하는 경우는 생략이 가능하다.

- **자손타입 -> 조상타입 (up casting)**: 생략가능
- **조상타입 -> 자손타입 (down casting)**: 생략 불가

참조변수간의 형변환은 캐스트 연산자를 사용하며, 괄호 안에 변환하고자 하는 타입의 이름을 적어주면 된다. 이렇게 형변환을 하는 이유는, 사용할 수 있는 멤버의 개수를 조절할 수 있다는 점을 들 수 있다.

**형변환은, 참조타입의 타입을 반환하는 것이지 인스턴스를 변환하는 것이 아니기 때문에 인스턴스에 아무런 영향을 미치지 않는다. 다만 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 조절하는 것 뿐이다.**

## instanceof 연산자

참조변수가 사용하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다. 조건문에 사용되며, 왼쪽에는 참조변수를 두고 오른쪽에는 타입이 피연산자로 위치한다. 그리고 연산의 결과로 true와 false를 반환한다. instanceof를 사용해 true를 얻었다는 것은 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.

예제코드를 살펴보면,

```java
void doWork(Car c) {
    if (c instanceof Truck) {
        Truck tr = (Truck) c;
        ...
    } else if (c instanceof Ban) {
        Ban b = (Ban) c;
        ...
    }
}
```

으로 나누어서 서로 다른 인스턴스로 형변환하여 사용이 가능하게 바꿀 수 있다. 또한, 이렇게 해서 인스턴스를 형변환하면 아무런 이상 없이 형변환이 가능하다.

**어떤 타입에 대해 instanceof 연산자가 참이라는 것은 검사한 타입으로의 형변환이 가능하다는 것을 나타낸다.**

## 참조변수와 인스턴스의 연결

조상 타입의 참조변수와 자손 타입의 참조변수는 사용할 수 있는 멤버의 개수에 차이가 있다.

조상 클래스에 선언된 멤버변수와 같은 이름의 인스턴스를 중복으로 정의했을 때, 조상 타입의 참조변수로 자손 인스턴스를 참조하는 경우와 자손 타입의 참조변수로 자손 인스턴스를 참조하는 결과는 서로 다른 결과를 얻는다.

메서드의 경우에는 반대로 조상 클래스의 메서드를 자손 클래스에서 오버라이딩해서 사용했을 경우에도 참조 타입에 관계없이 항상 같은 결과를 얻지만, **멤버변수의 경우는 참조변수의 타입에 따라 달라진다.**

또한, static 메서드는 static 변수처럼 참조변수의 타입에 영향을 받는다. 참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드 뿐이다. 그래서 static 메서드는 반드시 참조변수가 아닌 `클래스이름.메서드()`로 호출해야 한다.

멤버변수는, 조상 클래스와 자손 클래스에 중복으로 정의된 경우, 조상타입의 참조변수를 사용했을 때는 조상 클래스에 선언된 멤버변수가 사용되고, 자손타입의 참조변수를 사용했을 때는 자손 클래스에 선언된 멤버변수가 사용된다.

```java
public class Main {
    public static void main(String[] args) {
        class Parent {
            int x = 100;
            void method() {
                System.out.println("parents method");
            }
        }

        class Child extends Parent {
            int x = 200;
            void method() {
                System.out.println("x = " + x);
                System.out.println("super.x = " + super.x);
                System.out.println("this.x = " + this.x);
            }
        }

        Parent p = new Child();
        Child c = new Child();

        System.out.println("p.x = " + p.x);
        p.method();
        System.out.println("c.x = " + c.x);
        c.method();
    }
}
```

![테스트 코드 실행 결과](https://velog.velcdn.com/images/honggilgim/post/dce2dba9-8da6-4b18-9c58-d48ff92d04a5/image.png)

테스트 코드의 결과를 보면, parents의 변수는 조상 클래스의 Parents로부터 받은 x인 것을 알 수 있다. 또한, 자손 클래스의 인스턴스로 생성한 만큼 method는 모두 자손 클래스의 메서드이다. 이 점을 기억해두어야 하고, 인스턴스변수에 직접 접근할 경우 참조변수의 타입에 따라 사용되는 인스턴스 변수는 달라질 수 있다.

