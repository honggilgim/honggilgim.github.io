## 재귀 호출

메서드의 내부에서 자기 자신을 다시 호출하는 함수를 재귀 호출이라 한다. 재귀 호출을 하는 메서드를 재귀 메서드라고 한다.

```java
void example() {
    example();
}
```

메서드 입장에서는 자기 자신을 호출하는 일은 다른 메서드를 호출하는 것과 별 차이가 없다. 메서드 호출이라는 것은 그저 특정 위치에 있는 메서드를 호출하는 명령어를 수행하는 일이기 때문이다.

호출된 메서드는 값에 의한 호출을 통해, 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메서드와 관계없이 독립적인 작업수행이 가능하다.

물론 이렇게 하면 무한 루프에 빠지기 때문에, 재귀 호출에도 필수적으로 조건문이 붙는다.

```java
void example(int n) {
    if(n == 0)
        return;
    System.out.println(n);
    example(n--);
}
```

이렇게 할 경우 재귀 호출을 통해 진행하게 되며, 반복문

```java
while(n > 0) {
    System.out.println(n);
    n--;
}
```

와 같은 의미를 지닌다.

물론 반복문이 훨씬 효율적인데, 재귀 호출은 복귀할 주소의 저장 등 추가로 필요한 조건이 있어 반복문보단 효율이 떨어진다. 이런 재귀 호출을 사용하는 이유는 논리적 간결함 혹은 재귀 호출이 가지는 논리적 이점 때문이다. 알고리즘 문제를 풀다 보면 재귀적 호출을 많이 사용하게 되는데,

```java
int factorial(int n) {
    if(n == 1)
        return 1;
    else
        return n * factorial(n-1);
}
```

과 같은 식으로 팩토리얼을 구하는 식을 표현할 수 있다.

이 부분은 자바보다는 알고리즘을 공부하면 쉽게 이해할 수 있다.

하지만, 재귀 호출을 지속적으로 반복하다 보면 호출스택에 계속해서 쌓이는 메모리 때문에 StackOverflow 에러가 발생할 수 있다.

## 클래스 메서드(static 메서드)와 인스턴스 메서드

변수와 마찬가지로 앞에 static이 붙으면 클래스메서드이고 붙어있지 않으면 인스턴스 메서드이다.

클래스 메서드는 `클래스이름.메서드이름`과 같은 형식으로 간단하게 호출할 수 있지만 인스턴스 메서드는 반드시 객체를 생성해야만 호출이 가능하다.

클래스는 변수와 데이터에 관련된 메서드의 집합이므로, 같은 클래스 내에 있는 메서드와 멤버변수는 밀접한 관계가 있다.

인스턴스 메서드는 **인스턴스 변수와 관련된 작업을 하는, 메서드의 작업을 수행하는 데 인스턴스 변수를 필요로 하는 메서드**이다. 그래서 인스턴스 메서드는 인스턴스 변수가 필요한 상황에서 선언해야 하고,

클래스 메서드는 **인스턴스와 관계없는 즉 인스턴스 변수와 인스턴스 메서드를 사용하지 않는 메서드**를 클래스 메서드(static 메서드)로 정의한다.

보통 아주 중요하게 따지지는 않고 동작에도 이상이 가지 않는 경우가 대다수지만, 이렇게 하는 것이 일반적이다.

### 클래스 메서드와 인스턴스 메서드의 특징

1. 클래스 설계 시, 멤버변수 중 모든 인스턴스에 공통으로 사용되는 것에는 static을 붙여 클래스 변수로 만든다.
   - 생성된 각 인스턴스는 독립적이지만, 공통으로 사용되어야 하는 값들이 있다. 이러한 값들은 static을 붙여 공통성을 유지한다.

2. 클래스 변수(static 변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
   - static이 붙은 변수인 클래스변수는 메모리에 올라갈 때 자동적으로 생성된다.

3. 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다.
   - 인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드는 인스턴스 없이 호출이 가능하다. 그래서 클래스 메서드에 인스턴스 변수의 사용을 금지한다. 반면에, 인스턴스 변수나 인스턴스 메서드에 클래스 변수(static 변수)의 사용은 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 인스턴스가 생성되었다는 것이고, 이는 클래스 변수가 메모리에 올라갔다는 것을 의미한다.

4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙여준다.
   - 메서드의 작업내용 중 인스턴스 변수를 필요로 한다면 static을 붙일 수 없다. 하지만 인스턴스 변수를 필요로 하지 않는다면 static을 붙여 실행하자. 메서드 호출시간이 짧아져 성능이 향상된다. static을 붙이지 않는 메서드인 인스턴스 메서드는 실행 시 호출되어야 할 메모리를 찾아야 하기 때문에 시간이 더 걸린다.

### 좋은 코드 작성하는 규칙

1. 클래스의 멤버변수 중 모든 인스턴스에 공통된 값을 유지해야 하는 것이 있다면, static을 붙여준다.
2. 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드는 static을 붙여주는 것을 생각해본다.

```java
class Math {
    long a, b;
    
    // 인스턴스 메서드는 인스턴스 객체가 만들어져야 호출이 가능하다.
    long add() { return a + b; }
    long subtract() { return a - b; }
    long multiply() { return a * b; }
    double divide() { return a / b; }
    
    // 클래스 메서드 매개변수를 가져와서 작업을 진행하고, 인스턴스 생성없이 호출이 가능하다.
    static long add(long a, long b) { return a + b; }
    static long subtract(long a, long b) { return a - b; }
    static long multiply(long a, long b) { return a * b; }
    static double divide(long a, long b) { return a / b; }
}

public class Main {
    public static void main(String[] args) {
        // 클래스 메서드는 인스턴스 생성없이 호출이 가능하다. 인자를 받아와서 호출한다.
        System.out.println(Math.add(200L, 200L));
        System.out.println(Math.subtract(200L, 200L));
        System.out.println(Math.multiply(200L, 200L));
        System.out.println(Math.divide(200L, 200L));

        Math test = new Math();
        test.a = 10L;
        test.b = 20L;

        // 인스턴스 메서드는 인스턴스를 생성한 후 호출이 가능하다.
        System.out.println(test.add());
        System.out.println(test.subtract());
        System.out.println(test.multiply());
        System.out.println(test.divide());
    }
}
```

![실행 결과](https://velog.velcdn.com/images/honggilgim/post/aed70b6e-c08e-495c-b7a3-f2187a93e0f0/image.png)

우리가 흔히 사용하는 `StringUtils.isEmpty(String s)` 혹은 `Integer.parseInt(String s)`와 같은 다양한 자바 함수도 전부 클래스 메서드이다.

## 클래스 멤버와 인스턴스 멤버간의 참조와 호출

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스 생성 없이 참조 또는 호출이 가능하다. 단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 한다. 이는, **인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에는 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.**

그리고 클래스 멤버가 인스턴스 멤버를 호출 또는 참조해야 할 경우, 인스턴스 메서드로 작성해야 할 메서드를 클래스 메서드로 작성한 것은 아닌지 한번 의심해보고 확인해보아야 한다.

