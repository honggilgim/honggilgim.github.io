## 오버라이딩

### 오버라이딩이란?

조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다.

인터페이스 -> ServiceImpl로 구현했을 경우에도 이 오버라이딩 메서드를 찾아볼 수 있는데, 자바의 경우에는 특히 `@Override`라는 어노테이션을 붙여 이 메서드가 오버라이딩된 메서드라는 것을 알려주고 이를 체크하게 해 준다.

```java
@Transactional
@Override
public void deleteTicket(Long seq) {
    wishRepository.deleteById(seq);
    wishHistoryRepository.deleteByTicketSeq(seq);
}
```

간단한 예시 코드다. 부모 클래스는,

```java
public void deleteTicket(Long seq);
```

interface로 함수의 선언만 해 주고, 이후 서비스 단계에서 로직을 구현했다. 이 때 사용하는 것이 바로 오버라이드 기능이고 오버라이드 어노테이션이다.

### 오버라이딩의 조건

오버라이딩은 메서드의 내용만을 새로 작성하는 것이기에 메서드의 선언부는 조상의 것과 모든 부분이 일치해야 한다. 그 부분은,

1. 이름이 같아야 한다.
2. 매개변수가 같아야 한다.
3. 반환 타입이 같아야 한다.

즉, 선언부가 모두 같아야 오버라이딩이 가능하다. 다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

#### 1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.

조상 클래스가 protected라면, 자손 클래스의 오버라이딩 된 메서드는 접근 제어자가 protected나 public이어야 한다. 대부분의 경우는 같은 범위의 접근 제어자를 사용한다. 접근 제어자의 범위는, `public -> protected -> default -> private`이다.

#### 2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

예외의 크기 또한 문제가 되는데, 조상 클래스에서 IOException과 SQLException을 던졌는데 자식 클래스가 그냥 Exception을 던진다면 오류가 난다. 조상 클래스의 Exception 두 가지는, Exception의 하위 개념이므로 이 조건에 어긋난다.

#### 3. 인스턴스 메서드를 static 메서드 혹은 그 반대로 변경이 불가능하다.

만약 조상 클래스에 존재하는 static 메서드를 자손 클래스에서 Override 하더라도, 이는 다른 메서드가 된다. static 메서드는 선언된 클래스에 항상 묶여있다.

## 오버로딩 vs 오버라이딩

오버라이딩과 비슷한 개념으로 오버로딩이 존재한다. 이는,

- **오버로딩(overloading)**: 기존에 없는 새로운 메서드의 재정의
- **오버라이딩(overriding)**: 상속받은 메서드의 내용을 변경

코드로 보면,

```java
class Parents {
    void method() {}
}

class Child extends Parents {
    void method() {} // 오버라이딩
    void method(int a) {} // 오버로딩
    void childMethod() {} // 오버로딩
}
```

이 된다.

## super

super는, 자손 클래스에서 조상 클래스에서 상속받은 멤버를 참조하는 데 사용되는 참조 변수이다. 멤버변수와 지역변수의 이름이 같을 때는 this를 사용했듯이, 이 super는 상속받은 멤버와 자신의 이름이 같을 때 사용한다.

조상 클래스로부터 상속받은 멤버도 자손 클래스에서 super 대신 this를 사용할 수 있지만 조상 클래스의 멤버와 자손 클래스의 멤버가 중복 작성되어 있을 경우에는 super를 사용하는 편이 좋다.

this와 super는 근본적으로 같으며 이 두 변수 모두 자신이 속한 인스턴스의 주소를 가지고 있다. 두 변수 모두 static 메서드에는 사용할 수 없고 인스턴스 메서드에서만 사용이 가능하다.

## super()

조상 클래스의 생성자이다. this와의 차이는, this는 같은 클래스의 생성자를 호출하는 일에 사용되지만, super()는 조상 클래스의 생성자를 호출하는 일에 사용된다.

기본적으로 모든 클래스는 조상 클래스의 생성자를 기본 함수로 품고 있다. 이 조상 클래스의 인스턴스가 생성되어야, 자손 클래스의 인스턴스가 조상 클래스의 멤버를 사용할 수 있다. 그래서 보통 클래스에서는 조상 클래스의 생성자를 첫 줄에 생성한다. 또한, 조상 클래스 생성자의 호출은 상속 관계에 따라 Object 클래스의 생성자인 Object()까지 가야 종료된다.

그래서 모든 클래스들은 자신의 첫 줄에 this() 또는 super()를 호출해야 한다. 만약 그렇지 않다면 컴파일러는 생성자의 첫 줄에 자동으로 super()를 추가한다.

자손 클래스의 생성자를 정의할 때, 자신의 생성자 혹은 super()를 호출해 생성자가 꼬이는 일이 없도록 해야 한다.

## package와 import

### package(패키지)

패키지란, 클래스의 묶음이다. 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있으며, 서로 관련된 모든 클래스들끼리 그룹 단위로 묶어 놓음으로써 보다 효율적으로 클래스를 관리할 수 있다.

같은 클래스 이름이라도 서로 다른 패키지에 작성함으로써 똑같은 이름의 클래스가 동시에 존재할 수 있도록 할 수 있다. 클래스가 물리적으로 하나의 클래스파일인 것 같이, 패키지는 하나의 디렉토리이다. 그래서 어떤 패키지에 속한 클래스는 해당 디렉토리에 존재하는 클래스파일이어야 한다.

### 패키지의 선언

패키지의 선언은 간단하게 소스파일의 가장 첫줄에 `package 패키지명;`이라고 쳐서 적어두면 된다. 이 패키지 선언은 하나의 소스파일에 한 번만 선언될 수 있다. 또한 모든 클래스는 반드시 하나의 패키지에 소속되어야 한다. 지금까지 소속되어 있지 않아도 문제가 없던 이유는, 자바에서 기본적으로 이름없는 패키지를 제공하기 때문이다.

### import 문

소스코드를 작성하며 다른 패키지의 클래스를 사용하려면 반드시 import문을 작성해야 한다. import문은 컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공한다.

### import 문의 선언

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.bind.annotation.*; 
// 이 패키지의 모든 클래스를 사용할 수 있다.
```

이런 식으로 선언할 수 있다. `*`을 사용해도 실행 시 성능상의 이슈는 존재하지 않는다.

### static import 문

static import 문을 사용하면, static 멤버를 호출할 때 클래스 이름을 생략할 수 있다. 잘 안쓰이긴 하는데, 알아두면 좋을 거 같아 함께 적어둔다.

예:

```java
import static java.lang.Math.random;

System.out.println(random());
// Math.random() 메서드가 호출된다.
```

