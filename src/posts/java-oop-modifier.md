## 제어자

### 제어자란?

제어자는 클래스, 변수, 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다. 제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.

- **접근 제어자**: public, protected, default, private
- **그 외**: static, final, abstract, native, transient, synchronized, volatile, strictfp

제어자는 클래스 혹은 멤버변수와 메서드에 주로 사용되며, 하나의 대상에 대해 여러 제어자를 조합하여 사용하는 것이 가능하다. 다만 접근 제어자는 네 가지 중 하나만 선택하여 사용할 수 있다.

## static - 클래스의, 공통적인

static은 클래스의 혹은 공통적인 이라는 의미를 가지고 있다. 클래스변수는 인스턴스가 몇 개가 생성되더라도 항상 같은 값을 가지고 있다. 또한 static이 붙은 멤버변수와 메서드, 초기화 블럭은 인스턴스 생성 없이 사용이 가능하다. 이는 인스턴스가 아닌, 클래스에 의해 형성되었기 때문이다.

static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

### static 멤버변수

- 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
- 클래스변수는 인스턴스를 생성하지 않고도 사용 가능하다.
- 클래스는 메모리에 로드될 때 생성된다.

### static 메서드

- 인스턴스를 생성하지 않고도 호출이 가능한 static 메서드가 된다.
- static 메서드 내에서는 인스턴스멤버들을 직접 사용할 수 없다.

## final - 마지막의, 변경될 수 없는

final은 마지막의 또는 변경될 수 없는 이라는 의미를 가지고 있으며, 거의 모든 대상에 사용될 수 있다. 변수에 사용되면 값을 저장할 수 없는 상수가 되며, 메서드에 사용되면 오버라이딩을 할 수 없고 클래스에 사용되면 자신을 확장하는 자손 클래스에 정의할 수 없다.

### final 클래스

- 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.

### final 메서드

- 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 할 수 없다.

### final 멤버변수, 지역변수

- 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 된다.

### 생성자를 통한 final 멤버 변수 초기화

final로 선언하더라도, 상수로 선언되더라도 인스턴스 변수의 경우에는 생성자에서 초기화 될 수 있도록 할 수 있다. 클래스 내에서 매개변수를 갖는 생성자를 선언하여, 인스턴스를 생성할 때 final이 붙은 멤버변수를 초기화하는데 필요한 값을 생성자의 매개변수로부터 제공받는 것이다.

## abstract - 추상의, 미완성의

abstract는 '미완성'의 의미를 가지고 있다. 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않는 추상 메서드를 선언하는 데 사용된다.

abstract 클래스는 아직 완성되지 않은 메서드가 존재하는 미완성 클래스이므로, 인스턴스를 생성할 수 없다.

이 클래스는 나중에 다시 공부한다고 한다.

## 접근 제어자

접근 제어자는 멤버 또는 클래스에 사용되며, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 하는 역할을 맡는다.

접근 제어자가 사용될 수 있는 곳 - 클래스, 매개변수, 메서드, 생성자

- **private**: 같은 클래스 내에서만 접근이 가능하다.
- **default**: 같은 패키지 내에서만 접근이 가능하다.
- **protected**: 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근이 가능하다.
- **public**: 접근 제한이 없다.

### 접근 제어자를 이용한 캡슐화

클래스나 멤버, 주로 멤버에 접근 제어자를 사용하는 이유는 클래스의 내부에 선언된 데이터를 보호하기 위해서이다.

이것이 곧 객체지향의 캡슐화의 개념에 해당되며 이는 외부에서 접근할 필요가 없는 멤버들을 private로 지정하여 복잡성을 줄일 수 있다. 이는 곧 캡슐화이다.

접근 제어자를 사용하는 이유는,

- 외부로부터 데이터를 보호하기 위해
- 외부에서는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서라고 볼 수 있다.

이를 간단하게 표현하면,

```java
public class Date {
    public int month;
    public int day;
}
```

```java
Date d = new Date();
d.day = 33; // 33일은 없다.
d.month = 13; // 13월은 없다.
```

이런 형식의 데이터가 되고 이를 막을 수 있는 방법이 없다. 하지만,

```java
public class Date {
    private int month;
    private int day;
    
    void setMonth(int month) {
        if(month < 0 || month > 12)
            return;
        else
            this.month = month;
    }
    
    void setDay(int day) {
        if(day < 0 || day > 31)
            return;
        else
            this.day = day;
    }
}
```

```java
Date d = new Date();
d.setDay(33); // return;
d.setMonth(13); // return;
```

의 형식으로 데이터를 지킬 수 있다.

이 set으로 시작하는 메서드는 데이터의 값을 검사하여 맞을 경우에만 값을 작성하고, 맞지 않을 경우 값을 작성하지 않는다. 만일 상속을 통해 확장될 것이 예상되는 클래스라면, 멤버에 접근 제한을 주되 자손클래스에 접근하는 것이 가능하도록 하기 위해 private 대신 protected를 사용한다. private가 붙은 멤버는 자손 클래스에서도 접근이 불가능하다.

### 생성자의 접근 제어자

생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다. 보통 생성자의 접근 제어자는 클래스의 접근 제어자와 같지만, 다르게 지정할 수도 있다.

생성자의 접근 제어자에 private을 지정하면 외부에서 생성자에 접근할 수 없으므로 곧 인스턴스를 생성할 수 없게 된다. 그래도 클래스 내부에서는 인스턴스 생성이 가능하고, public 메서드를 통해 인스턴스를 사용할 수 있게 지정할 수 있다.

거의 사용되는 사안을 본 적이 없지만, 자주 사용하는 Math 클래스가 이 생성자를 private으로 막아놓은 메서드이다.

이는, Math 클래스는 몇 개의 상수와 static 메서드로만 구성되어 있기 때문이다.

```java
public final class Math {
    private Math() {
    }
}
```

## 제어자 정리

- **클래스**: public, (default), final, abstract
- **메서드**: 모든 접근 제어자, final, abstract, static
- **멤버 변수**: 모든 접근 제어자, final, static
- **지역변수**: final

### 주의사항

1. **메서드에 static과 abstract를 함께 사용할 수 없다.**
   - static 메서드는 몸통이 있는 메서드에만 사용이 가능하다. abstract 메서드는 몸통이 없다.

2. **클래스에 abstract와 final을 동시에 사용할 수 없다.**
   - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고, abstract는 상속을 통해서만 완성되어야 하기 때문에 이는 모순된다.

3. **abstract 메서드는 접근 제어자가 private일 수 없다.**
   - abstract 메서드는 자손클래스에서 구현해주어야 하는데, 접근 제어자가 private이면, 자손클래스에서의 접근 자체가 불가능하다.

4. **메서드에 private와 final을 같이 사용할 필요는 없다.**
   - 접근 제어자가 private인 메서드는 어차피 오버라이딩이 안 된다.

